"use strict";

var _ = require('lodash-node');
var when = require('when');

var cmn = require('./cmnData');
var createClosestEventCall;

var SEC = 1000;

// Выполняет ближайшее событие
function execClosestEv () {
    if (!createClosestEventCall) {
        createClosestEventCall = require('./createClosestEventCall');
    }

    cmn.db
        .oneOrNone('' +
        'SELECT "id", "event_type", "user_uuid", "call_at_time", "blocked_at", "call_data", "event_data", "created"' +
        ' FROM "call_by_time_events"' +
        ' WHERE "call_at_time" < ${now} AND blocked_at IS NULL' +
        ' ORDER BY "call_at_time"' +
        ' LIMIT 1;', {now: new Date()}
    )
        .then(function(eventData){
            if (eventData) {
                eventData.call_data = JSON.parse(eventData.call_data || '{}');
                eventData.event_data = JSON.parse(eventData.event_data || '{}');

                //console.log('Найдена задача на исполнение в ' + eventData.call_at_time.toISOString());
                return cmn.db.query(
                    'UPDATE "call_by_time_events" SET "blocked_at" = ${now} WHERE "id" = ${id} AND blocked_at IS NULL RETURNING blocked_at;',
                    {id: eventData.id, now: new Date()}
                )
                    .then(function(data){
                        if (data && data.length) {
                            // заблокировали то что хотели
                            execEvent(eventData);
                            createClosestEventCall();
                        } else {
                            // Кто-то уже до нас заблокировал задачу
                            createClosestEventCall();
                        }
                    });
            } else {
                // Нечего делать
                createClosestEventCall();
            }
        })
        .then(
        null,
        function(err){
            console.error('execClosestEv:' + err.stack);
        }
    );
}

function execEvent (event) {
    var event_data = event.event_data,
        evType = event_data.evtype,
        exec = cmn.callMeTypes[evType],
        def;

    if (!exec) {
        console.error('execEvent: Нет обработчика "' + evType + '"');
        def = when.resolve();
    } else {
        def = exec(event.event_type, event.user_uuid, event_data, event.call_data);
        if (!when.isPromiseLike(def)) {
            console.error('Exec fn for type "'+evType+'" shoud return when.defer()');
            def = when.resolve();
        }
    }

    def.then(
        function(){
            return cmn.db.none('DELETE FROM "call_by_time_events" WHERE "id" = ${id};', {id: event.id});
        },
        function(err){
            return cmn.db.none(
                'UPDATE "call_by_time_events" SET "call_at_time" = ${call_at_time}, "event_data" = ${event_data}, "blocked_at" = null WHERE "id" = ${id};',
                {
                    id: event.id,
                    call_at_time: _.isDate(err) ? err : new Date(Date.now() + 5 * SEC),
                    event_data: JSON.stringify(event_data)
                }
            );
        }
    )
        .finally(createClosestEventCall);
}

module.exports = execClosestEv;