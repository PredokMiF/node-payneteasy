"use strict";

var _ = require('lodash-node');
var when = require('when');
var pgpLib = require('pg-promise');
var DbUpdater = require('dbupdater');

var cmn = require('./cmnData');
var createClosestEventCall = require('./createClosestEventCall');

// Инициализация библиотеки
function init (pgConnect, dbTableName) {
    if (!_.isString(pgConnect) && !_.isPlainObject(pgConnect) || arguments.length > 1 && !_.isString(dbTableName)) {
        return when.reject('CallByTime.init: pgConnectStr и dbTableName д.б. сторками');
    }

    var pgp = pgpLib({
        promiseLib: when
    });
    cmn.db = pgp(pgConnect);

    return when
        // DbUpdater init
        .promise(function(resolve, reject, notify) {
            dbTableName = dbTableName || 'dbupdater_call_by_time';
            var dbUpdater = DbUpdater({
                taskReader: DbUpdater.TaskReaderFile({path: cmn.DB_UPDATER_SRC}),
                taskSaver: DbUpdater.TaskSaverPostgreSQL({connString: pgConnect, dbTable: dbTableName}),
                taskExecutors: [
                    DbUpdater.TaskExecPostgresFileJs({connString: pgConnect}),
                    DbUpdater.TaskExecPostgresFileSql({connString: pgConnect})
                ]
            });

            dbUpdater.init(function (err) {
                if (err) {
                    reject(err);
                } else {
                    resolve();
                }
            });
        })
        // Проверяем что запросы нормально работают
        .then(function() {
            return cmn.db.any('' +
            'SELECT "id", "event_type", "user_uuid", "call_at_time", "blocked_at", "call_data", "event_data", "created"' +
            ' FROM "call_by_time_events"' +
            ' WHERE "call_at_time" < ${now} AND blocked_at IS NULL' +
            ' ORDER BY "call_at_time"' +
            ' LIMIT 1;', {now: new Date()})
        })
        // Поиск запросов для выполнения (бесконечный цикл). На случай, если createClosestEventCall даст сбой
        .then(function() {
            //console.log('Поиск задач по расписанию');
            createClosestEventCall();
            setInterval(function(){
                //console.log('Поиск задач по расписанию');
                createClosestEventCall();
            }, cmn.EVENT_POOL_INTERVAL);
        })
        // Поиск зависших запросов (бесконечный цикл). На случай, если выполнение слишком затянется
        .then(function() {
            setInterval(function () {
                var deadblockTime = new Date(Date.now() - cmn.EVENT_DEADBLOCK_FIND_POOL_INTERVAL);
                //console.log('Поиск заблокированных задач ' + deadblockTime.toISOString());
                cmn.db.any('UPDATE "call_by_time_events" SET "blocked_at" = null WHERE "blocked_at" < ${dedblockTime};', {dedblockTime: deadblockTime})
            }, cmn.EVENT_DEADBLOCK_FIND_POOL_INTERVAL);
        });
}

module.exports = init;