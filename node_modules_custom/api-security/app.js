"use strict";

var _ = require('lodash-node');

var v = require(__modulesCustom + 'strong-validator');
var HandledError = require(__modulesCustom + 'handledError');

function apiSecurity (config, cb) {
    var error, ctx = {};

    if (!_.isPlainObject(config) || !_.isFunction(cb)) {
        error = new HandledError('При описании сервиса, не указали конфигурацию или обработчик. Обратитесь к администратору ресурса');
    } else if (!config.APIVer) {
        error = new HandledError('При описании сервиса, не указали версию. Обратитесь к администратору ресурса');
    } else if (config.role && ['unauth', 'all', 'user', 'admin'].indexOf(config.role) === -1) {
        error = new HandledError('При описании сервиса, не верно указали права доступа. Обратитесь к администратору ресурса');
    }

    if (!error && config.reqUrlValidate) {
        ctx.reqUrlParamsValidate = v(config.reqUrlValidate);
    }
    if (!error && config.reqQueryValidate) {
        ctx.reqQueryParamsValidate = v(config.reqQueryValidate);
    }
    if (!error && config.reqBodyValidate) {
        ctx.reqBodyParamsValidate = v(config.reqBodyValidate);
    }

    if (error) {
        return function (req, res, next) {
            next(error);
        }
    } else {
        return function (req, res, next) {
            if (config.APIVer !== 'none') {
                if (!req.params || !req.params.APIVer) {
                    next(new HandledError('В запросе не указана версия API роута'));
                    return;
                } else if (req.params.APIVer !== config.APIVer) {
                    req.__myAPIVerError = true;
                    next();
                    return;
                }
                delete req.params.APIVer;
            }

            if (config.role === 'all') {
                validateParams(ctx, cb, req, res, next);
            } else  if (config.role === 'unauth') {
                req.session.regenerate(function (err) {
                    if (err) {
                        next(err);
                    } else {
                        validateParams(ctx, cb, req, res, next);
                    }
                });
            } else if (!req.session.user) {
                next(new HandledError(401, 'Unauthorized', {ERROR_MSG_CODE: 'UNAUTHORIZED'}));
            } else if (req.session.user && req.session.user.roles && req.session.user.roles.length && req.session.user.roles.indexOf(config.role) !== -1) {
                validateParams(ctx, cb, req, res, next);
            } else {
                next(new HandledError(550, 'Permission denied', {ERROR_MSG_CODE: 'PERMISSION_DENIED'}));
            }
        }
    }
}

function validateParams (ctx, cb, req, res, next) {
    validateUrlParams (ctx, cb, req, res, next);
}

function validateUrlParams (ctx, cb, req, res, next) {
    if (ctx.reqUrlParamsValidate) {
        ctx.reqUrlParamsValidate(req.params).
            then(function (result) {
                req.params = result;
                validateQueryParams(ctx, cb, req, res, next);
            }, function (err) {
                next(new HandledError(err));
            });
    } else {
        validateQueryParams(ctx, cb, req, res, next);
    }
}

function validateQueryParams (ctx, cb, req, res, next) {
    if (ctx.reqQueryParamsValidate) {
        ctx.reqQueryParamsValidate(req.query).
            then(function (result) {
                req.query = result;
                validatePostParams(ctx, cb, req, res, next);
            }, function (err) {
                next(new HandledError(err));
            });
    } else {
        validatePostParams(ctx, cb, req, res, next);
    }
}

function validatePostParams (ctx, cb, req, res, next) {
    if (ctx.reqBodyParamsValidate) {
        ctx.reqBodyParamsValidate(req.body).
            then(function (result) {
                req.body = result;
                doNext(ctx, cb, req, res, next);
            }, function (err) {
                next(new HandledError(err));
            });
    } else {
        doNext(ctx, cb, req, res, next);
    }
}

function doNext (ctx, cb, req, res, next) {
    try {
        var def = cb(req, res, next);
        if (def && def.then) {
            def.then(
                undefined,
                next
            )
                .catch(next)
                .finally(function(){
                    setTimeout(function(){
                        if (!res.headersSent) {
                            next(new HandledError(408, 'Request Timeout', {ERROR_MSG_CODE: 'REQUEST_TIMEOUT', CMN: 'Res not send'}));
                        }
                    }, 10000);
                })
        } else {
            console.error('Роут должен возвращать deferred');
        }
    } catch (e) {
        next(e);
    }
}

module.exports = apiSecurity;